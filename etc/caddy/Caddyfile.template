import debug/${DEBUG_LEVEL}

:80 {
    root * ${WEB_ROOT}

    # First check if file exists - if so, proxy to WordPress
    @exists {
        file {
            try_files {path} {path}/
        }
    }
    handle @exists {
        reverse_proxy ${INTERNAL_BACKEND_SCHEME}://${INTERNAL_BACKEND_HOSTNAME}:${INTERNAL_BACKEND_PORT} {
            header_up Host "${INTERNAL_HEADER_UP_HOST}"
            header_up X-Real-IP {remote_host}
            import transport/${INTERNAL_BACKEND_SCHEME}
        }
    }

    # If file doesn't exist and matches the pattern, proxy to other backend
    @external_backend {
        path_regexp external ${EXTERNAL_BACKEND_PATTERN}
        not file {
            try_files {path} {path}/
        }
    }
    handle @external_backend {
        reverse_proxy ${EXTERNAL_BACKEND_SCHEME}://${EXTERNAL_BACKEND_HOSTNAME}:${EXTERNAL_BACKEND_PORT} {
            header_up Host "${EXTERNAL_HEADER_UP_HOST}"
            import transport/${EXTERNAL_BACKEND_SCHEME}
        }
    }

    # Default: if no match above, proxy to WordPress
    handle {
        reverse_proxy ${INTERNAL_BACKEND_SCHEME}://${INTERNAL_BACKEND_HOSTNAME}:${INTERNAL_BACKEND_PORT} {
            header_up Host "${INTERNAL_HEADER_UP_HOST}"
            header_up X-Real-IP {remote_host}
            import transport/${INTERNAL_BACKEND_SCHEME}
        }
    }

    # Common security headers
    header {
        X-Frame-Options "SAMEORIGIN"
        X-XSS-Protection "1; mode=block"
        X-Content-Type-Options "nosniff"
        Referrer-Policy "strict-origin-when-cross-origin"
    }

    # Enable compression
    encode gzip
}
